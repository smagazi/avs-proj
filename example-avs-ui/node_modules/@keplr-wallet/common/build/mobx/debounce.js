"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DebounceActionTimer = void 0;
const mobx_1 = require("mobx");
class DebounceActionTimer {
    constructor(debounceMs, handler) {
        this.debounceMs = debounceMs;
        this.handler = handler;
        this.requests = [];
        this.startTime = 0;
        this.tick = () => {
            let shouldExec = this.debounceMs <= 0;
            if (this.debounceMs > 0) {
                const now = Date.now();
                if (now - this.startTime >= this.debounceMs) {
                    shouldExec = true;
                }
            }
            if (shouldExec) {
                // Should use sliced (copied) array
                const requests = this.requests.slice();
                const responses = this.handler(requests);
                if (typeof responses === "object" && "then" in responses) {
                    Promise.resolve(responses).then((responses) => {
                        this.handleResponses(requests, responses);
                    });
                }
                else {
                    this.handleResponses(requests, responses);
                }
                this.requests = [];
            }
            else {
                this.nextTick(this.tick);
            }
        };
        this.handleResponses = (requests, responses) => {
            (0, mobx_1.runInAction)(() => {
                for (let i = 0; i < requests.length; i++) {
                    const req = requests[i];
                    const res = responses[i];
                    req.action(res);
                }
            });
            for (const req of requests) {
                req.resolver();
            }
        };
    }
    call(args, action) {
        return new Promise((resolve) => {
            const newStart = this.requests.length === 0;
            this.requests.push({ args, action, resolver: resolve });
            if (newStart) {
                this.startTimer();
            }
        });
    }
    startTimer() {
        this.startTime = Date.now();
        this.nextTick(this.tick);
    }
    nextTick(fn) {
        if (this.debounceMs <= 0) {
            Promise.resolve().then(fn);
            return;
        }
        if (typeof window !== "undefined" && window.requestAnimationFrame) {
            window.requestAnimationFrame(fn);
        }
        else {
            setTimeout(fn, this.debounceMs);
        }
    }
}
exports.DebounceActionTimer = DebounceActionTimer;
//# sourceMappingURL=debounce.js.map
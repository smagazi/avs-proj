"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PubKeySecp256k1 = exports.PrivKeySecp256k1 = void 0;
const elliptic_1 = require("elliptic");
const crypto_js_1 = __importDefault(require("crypto-js"));
const buffer_1 = require("buffer/");
const hash_1 = require("./hash");
class PrivKeySecp256k1 {
    static generateRandomKey() {
        const secp256k1 = new elliptic_1.ec("secp256k1");
        return new PrivKeySecp256k1(buffer_1.Buffer.from(secp256k1.genKeyPair().getPrivate().toArray()));
    }
    constructor(privKey) {
        this.privKey = privKey;
    }
    toBytes() {
        return new Uint8Array(this.privKey);
    }
    getPubKey() {
        const secp256k1 = new elliptic_1.ec("secp256k1");
        const key = secp256k1.keyFromPrivate(this.privKey);
        return new PubKeySecp256k1(new Uint8Array(key.getPublic().encodeCompressed("array")));
    }
    signDigest32(digest) {
        if (digest.length !== 32) {
            throw new Error(`Invalid length of digest to sign: ${digest.length}`);
        }
        const secp256k1 = new elliptic_1.ec("secp256k1");
        const key = secp256k1.keyFromPrivate(this.privKey);
        const signature = key.sign(digest, {
            canonical: true,
        });
        return {
            r: new Uint8Array(signature.r.toArray("be", 32)),
            s: new Uint8Array(signature.s.toArray("be", 32)),
            v: signature.recoveryParam,
        };
    }
}
exports.PrivKeySecp256k1 = PrivKeySecp256k1;
class PubKeySecp256k1 {
    constructor(pubKey) {
        this.pubKey = pubKey;
        if (pubKey.length !== 33 && pubKey.length !== 65) {
            throw new Error(`Invalid length of public key: ${pubKey.length}`);
        }
    }
    toBytes(uncompressed) {
        if (uncompressed && this.pubKey.length === 65) {
            return this.pubKey;
        }
        if (!uncompressed && this.pubKey.length === 33) {
            return this.pubKey;
        }
        const keyPair = this.toKeyPair();
        if (uncompressed) {
            return new Uint8Array(buffer_1.Buffer.from(keyPair.getPublic().encode("hex", false), "hex"));
        }
        else {
            return new Uint8Array(buffer_1.Buffer.from(keyPair.getPublic().encodeCompressed("hex"), "hex"));
        }
    }
    /**
     * @deprecated Use `getCosmosAddress()` instead.
     */
    getAddress() {
        return this.getCosmosAddress();
    }
    getCosmosAddress() {
        let hash = crypto_js_1.default.SHA256(crypto_js_1.default.lib.WordArray.create(this.toBytes(false))).toString();
        hash = crypto_js_1.default.RIPEMD160(crypto_js_1.default.enc.Hex.parse(hash)).toString();
        return new Uint8Array(buffer_1.Buffer.from(hash, "hex"));
    }
    getEthAddress() {
        // Should be uncompressed.
        // And remove prefix byte.
        // And hash by keccak256.
        // Use last 20 bytes.
        return hash_1.Hash.keccak256(this.toBytes(true).slice(1)).slice(-20);
    }
    toKeyPair() {
        const secp256k1 = new elliptic_1.ec("secp256k1");
        return secp256k1.keyFromPublic(buffer_1.Buffer.from(this.pubKey).toString("hex"), "hex");
    }
    verifyDigest32(digest, signature) {
        if (digest.length !== 32) {
            throw new Error(`Invalid length of digest to verify: ${digest.length}`);
        }
        if (signature.length !== 64) {
            throw new Error(`Invalid length of signature: ${signature.length}`);
        }
        const secp256k1 = new elliptic_1.ec("secp256k1");
        const r = signature.slice(0, 32);
        const s = signature.slice(32);
        return secp256k1.verify(digest, {
            r: buffer_1.Buffer.from(r).toString("hex"),
            s: buffer_1.Buffer.from(s).toString("hex"),
        }, this.toKeyPair());
    }
}
exports.PubKeySecp256k1 = PubKeySecp256k1;
//# sourceMappingURL=key.js.map